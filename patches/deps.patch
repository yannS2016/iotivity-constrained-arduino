Only in deps_old/: IotivitySerial
Only in deps_old/: mather
Only in deps_old/pRNG: build-mega2560
diff -ru deps/pRNG/Makefile deps_old/pRNG/Makefile
--- deps/pRNG/Makefile	2019-01-17 17:05:29.659829694 +0000
+++ deps_old/pRNG/Makefile	2019-01-17 17:14:17.750432427 +0000
@@ -0,0 +1,13 @@
+###iotivity contrained sources
+include ../../../setup.mk 
+
+SRC=$(wildcard ./*.cpp) 
+
+LOCAL_CPP_SRCS += $(SRC) 
+
+include $(ARDMK_DIR)/Arduino.mk 
+
+build-$(BOARD_TAG)/libarduino-prng.a: $(LOCAL_OBJS)
+	$(AR) rcs $@ $(LOCAL_OBJS)
+	
+
diff -ru deps/pRNG/prng.cpp deps_old/pRNG/prng.cpp
--- deps/pRNG/prng.cpp	2019-01-17 17:06:00.659860664 +0000
+++ deps_old/pRNG/prng.cpp	2019-01-17 17:14:17.750432427 +0000
@@ -0,0 +1,61 @@
+#include <Arduino.h>
+//#include <stdint.h>
+#include "prng.h"
+#include "pRNG.h"
+#include <stdio.h>
+struct prng {
+    void *cpp_ref;
+};
+prng_t *iotConstrainedRand = NULL;
+
+prng_t *prng_create()
+{
+    prng_t *cpp_ref_holder;
+    pRNG *cpp_ref;
+    
+    cpp_ref_holder     = (typeof(cpp_ref_holder))malloc(sizeof(*cpp_ref_holder));
+    cpp_ref    = new pRNG();
+    cpp_ref_holder->cpp_ref = cpp_ref;
+    //printf_P(PSTR("\r\nInit Random\r\n"));
+    return cpp_ref_holder;
+}
+ 
+void prng_destroy(prng_t *cpp_ref_holder)
+{
+    if (cpp_ref_holder== NULL)
+        return;
+    delete static_cast<pRNG *>(cpp_ref_holder->cpp_ref);
+    free(cpp_ref_holder);
+}
+uint8_t prng_getRndByte(prng_t *cpp_ref_holder){
+
+    pRNG *cpp_ref;
+ 
+    if (cpp_ref_holder== NULL)
+        return 1;
+ 
+    cpp_ref = static_cast<pRNG *>(cpp_ref_holder->cpp_ref);
+    return cpp_ref->getRndByte();
+}
+
+uint16_t prng_getRndInt(prng_t *cpp_ref_holder){
+
+    pRNG *cpp_ref;
+ 
+    if (cpp_ref_holder== NULL)
+        return 1;
+ 
+    cpp_ref = static_cast<pRNG *>(cpp_ref_holder->cpp_ref);
+    return cpp_ref->getRndInt();
+}
+
+uint32_t prng_getRndLong(prng_t *cpp_ref_holder){
+
+    pRNG *cpp_ref;
+ 
+    if (cpp_ref_holder== NULL)
+        return 1;
+ 
+    cpp_ref = static_cast<pRNG *>(cpp_ref_holder->cpp_ref);
+    return cpp_ref->getRndLong();
+}
\ No newline at end of file
diff -ru deps/pRNG/prng.h deps_old/pRNG/prng.h
--- deps/pRNG/prng.h	2019-01-17 17:06:23.309883322 +0000
+++ deps_old/pRNG/prng.h	2019-01-17 17:14:17.750432427 +0000
@@ -0,0 +1,25 @@
+#ifndef __PRNG_H__
+#define __PRNG_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include <stdint.h>  
+#include <stdlib.h> 
+struct prng;
+typedef struct prng prng_t;
+
+extern prng_t *iotConstrainedRand;// = NULL; 
+
+prng_t *prng_create();
+void prng_destroy(prng_t *m);
+ 
+uint8_t prng_getRndByte(prng_t *m);
+uint16_t prng_getRndInt(prng_t *m);
+uint32_t prng_getRndLong(prng_t *m);
+ 
+#ifdef __cplusplus
+}
+#endif
+ 
+#endif /* __PRNG_H__ */
Only in deps_old/rs232: build-mega2560
diff -ru deps/rs232/Makefile deps_old/rs232/Makefile
--- deps/rs232/Makefile	2019-01-17 17:08:52.510033178 +0000
+++ deps_old/rs232/Makefile	2019-01-17 17:14:17.740432406 +0000
@@ -0,0 +1,73 @@
+###iotivity contrained sources
+include ../../../setup.mk 
+
+#ifndef USART_BAUD
+USART_BAUD	= 115200
+#endif
+
+ARDUINO_MODEL =  Mega
+
+# http://arduino.cc/en/Main/Boards
+ifeq ($(ARDUINO_MODEL), Diecimila) # ATmega168 @ 16MHz
+# http://www.arduino.cc/en/Main/ArduinoBoardDiecimila
+AVR_MCU_CLOCK	= 16
+AVR_MCU_SPEED	= 16000000UL
+MCU		= atmega168
+USART_PORT	= 0
+
+else ifeq ($(ARDUINO_MODEL), ProMini8MHz) # ATmega168 @ 8MHz (3.3V)
+# http://www.arduino.cc/en/Main/ArduinoBoardProMini
+AVR_MCU_CLOCK	= 8
+AVR_MCU_SPEED	= 8000000UL
+MCU		= atmega168
+USART_PORT	= 0
+
+else ifeq ($(ARDUINO_MODEL), ProMini16MHz) # ATmega168 @ 16MHz (5V)
+# http://www.arduino.cc/en/Main/ArduinoBoardProMini
+AVR_MCU_CLOCK	= 16
+AVR_MCU_SPEED	= 16000000UL
+MCU		= atmega168
+USART_PORT	= 0
+
+else ifeq ($(ARDUINO_MODEL), Duemilanove-328) # ATmega328p @ 16MHz (5V)
+# http://arduino.cc/en/Main/ArduinoBoardDuemilanove
+AVR_MCU_CLOCK	= 16
+AVR_MCU_SPEED	= 16000000UL
+MCU		= atmega328p
+USART_PORT	= 0
+
+else ifeq ($(ARDUINO_MODEL), Uno) # ATmega328p @ 16MHz (5V)
+# http://arduino.cc/en/Main/ArduinoBoardUno
+AVR_MCU_CLOCK	= 16
+AVR_MCU_SPEED	= 16000000UL
+MCU		= atmega328p 
+USART_PORT	= 0
+
+else ifeq ($(ARDUINO_MODEL), Mega) # ATmega2560 @ 16MHz (5V)
+# http://arduino.cc/en/Main/ArduinoBoardUno
+AVR_MCU_CLOCK	= 16
+AVR_MCU_SPEED	= 16000000UL
+MCU		= atmega2560 
+USART_PORT	= 0
+
+else
+$(error Please define Arduino board model in Makefile.arduino)
+endif
+
+
+RS232_PLAT_DEFS	= -DF_CPU=$(AVR_MCU_SPEED) \
+			  -DMCU_MHZ=$(AVR_MCU_CLOCK) \
+			  -DAUTO_CRC_PADDING=2 \
+			  -DUSART_BAUD=USART_BAUD_$(USART_BAUD) \
+			  -DUSART_PORT=RS232_PORT_$(USART_PORT)
+
+#CFLAGS += $(RS232_PLAT_DEFS)
+
+SRC=$(wildcard ./*.c) 
+
+LOCAL_C_SRCS += $(SRC) 
+
+include $(ARDMK_DIR)/Arduino.mk 
+
+build-$(BOARD_TAG)/libarduino-rs232.a: $(LOCAL_OBJS)
+	$(AR) rcs $@ $(LOCAL_OBJS)				
\ No newline at end of file
diff -ru deps/rs232/rs232_atmega2560.h deps_old/rs232/rs232_atmega2560.h
--- deps/rs232/rs232_atmega2560.h	2019-01-17 17:09:00.920041656 +0000
+++ deps_old/rs232/rs232_atmega2560.h	2019-01-17 17:14:17.740432406 +0000
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) 2006, Technical University of Munich
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the Contiki operating system.
+ *
+ * @(#)$$
+ */
+
+/**
+ * \file
+ *         AVR specific definitions for the rs232 port.
+ *
+ * \author
+ *         Simon Barner <barner@in.tum.de
+ */
+
+#ifndef __RS232_ATMEGA2560__
+#define __RS232_ATMEGA2560__
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/******************************************************************************/
+/***   Includes                                                               */
+/******************************************************************************/
+#include <avr/io.h>
+
+/******************************************************************************/
+/***   RS232 ports                                                            */
+/******************************************************************************/
+#define RS232_PORT_0 0
+#define RS232_PORT_1 1
+#define RS232_PORT_2 2
+#define RS232_PORT_3 3
+/******************************************************************************/
+/***   Baud rates                                                             */
+/******************************************************************************/
+#if (F_CPU == 16000000UL)
+/* Single speed operation (U2X = 0)*/
+#define USART_BAUD_2400 416
+#define USART_BAUD_4800 207
+#define USART_BAUD_9600 103
+#define USART_BAUD_14400 68
+#define USART_BAUD_19200 51
+#define USART_BAUD_28800 34
+#define USART_BAUD_38400 25
+#define USART_BAUD_57600 16
+#define USART_BAUD_76800 12
+#define USART_BAUD_115200 8
+#define USART_BAUD_230400 3
+#define USART_BAUD_250000 3
+#define USART_BAUD_500000 1
+#define USART_BAUD_1000000 0
+#elif (F_CPU == 8000000UL)
+/* Single speed operation (U2X = 0)*/
+#define USART_BAUD_2400 207
+#define USART_BAUD_4800 103
+#define USART_BAUD_9600 51
+#define USART_BAUD_14400 34
+#define USART_BAUD_19200 25
+#define USART_BAUD_28800 16
+#define USART_BAUD_38400 12
+#define USART_BAUD_57600 8
+#define USART_BAUD_76800 6
+#define USART_BAUD_115200 3
+#define USART_BAUD_230400 1
+#define USART_BAUD_250000 1
+#define USART_BAUD_500000 0
+#elif (F_CPU == 4000000UL)
+/* Single speed operation (U2X = 0)*/
+#define USART_BAUD_2400 103
+#define USART_BAUD_4800 51
+#define USART_BAUD_9600 25
+#define USART_BAUD_14400 16
+#define USART_BAUD_19200 12
+#define USART_BAUD_28800 8
+#define USART_BAUD_38400 6
+#define USART_BAUD_57600 3
+#define USART_BAUD_76800 2
+#define USART_BAUD_115200 1
+#define USART_BAUD_230400 0
+#define USART_BAUD_250000 0
+#define USART_BAUD_500000 0
+#else
+#error "Please define the baud rates for your CPU clock: ATmega128 handbook p. \
+195-198 or set the rate in contiki-conf.h"
+#endif
+
+
+/******************************************************************************/
+/***   Interrupt settings                                                     */
+/******************************************************************************/
+#define USART_INTERRUPT_RX_COMPLETE _BV (RXCIE0)
+#define USART_INTERRUPT_TX_COMPLETE _BV (TXCIE0)
+#define USART_INTERRUPT_DATA_REG_EMPTY _BV (UDRIE0)
+
+/******************************************************************************/
+/***   Receiver / transmitter                                                 */
+/******************************************************************************/
+#define USART_RECEIVER_ENABLE _BV (RXEN0)
+#define USART_TRANSMITTER_ENABLE _BV (TXEN0)
+
+/******************************************************************************/
+/***   Mode select                                                            */
+/******************************************************************************/
+#define USART_MODE_ASYNC 0x00
+#define USART_MODE_SYNC _BV (UMSEL00)
+
+/******************************************************************************/
+/***   Parity                                                                 */
+/******************************************************************************/
+#define USART_PARITY_NONE 0x00
+#define USART_PARITY_EVEN _BV (UPM01)
+#define USART_PARITY_ODD  _BV (UPM01) | _BV (UPM00)
+
+/******************************************************************************/
+/***   Stop bits                                                              */
+/******************************************************************************/
+#define USART_STOP_BITS_1 0x00
+#define USART_STOP_BITS_2 _BV (USBS0)
+
+/******************************************************************************/
+/***   Character size                                                         */
+/******************************************************************************/
+#define USART_DATA_BITS_5 0x00
+#define USART_DATA_BITS_6 _BV (UCSZ00)
+#define USART_DATA_BITS_7 _BV (UCSZ01)
+#define USART_DATA_BITS_8 _BV (UCSZ01) | _BV (UCSZ00)
+// #define USART_DATA_BITS_9 (needs also UCSZ2 bit in UCSRnB)
+
+/******************************************************************************/
+/***   Clock polarity                                                         */
+/******************************************************************************/
+#define USART_RISING_XCKN_EDGE 0x00
+#define USART_FALLING_XCKN_EDGE _BV (UCPOL0)
+#ifdef __cplusplus
+}
+#endif
+#endif /* #ifndef __RS232_ATMEGA2560__ */
diff -ru deps/rs232/rs232.c deps_old/rs232/rs232.c
--- deps/rs232/rs232.c	2019-01-17 17:09:09.280050087 +0000
+++ deps_old/rs232/rs232.c	2019-01-17 17:14:17.740432406 +0000
@@ -0,0 +1,493 @@
+/*
+ * Copyright (c) 2005, Swedish Institute of Computer Science
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the Contiki operating system.
+ *
+ */
+
+#include <stdio.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+
+#include "rs232.h"
+
+/*ATmega32 and smaller have UBRRH/UCSRC at the same I/O address.
+ *USART_UCSRC_SEL (bit7) selects writing to UBRHH(0) or UCSRC(1).
+ *It is OR'd in below so if not defined we can just set it to zero.
+ */
+#ifndef USART_UCSRC_SEL
+#define USART_UCSRC_SEL 0x00
+#endif
+
+/* Currently only the STK500 platform uses a static RAM buffer for printfs.
+ * Others print a character at a time using the gcc string pointer.
+ * gcc may not strip the unused buffer, even though it is statically
+ * allocated in an unused routine.
+ */
+#ifdef RS232_CONF_PRINTF_BUFFER_LENGTH
+#define RS232_PRINTF_BUFFER_LENGTH RS232_CONF_PRINTF_BUFFER_LENGTH
+#else
+#if CONTIKI_TARGET_STK500
+#define RS232_PRINTF_BUFFER_LENGTH 64
+#endif
+#endif
+
+/* TX interrupts would allow non-blocking output up to the size of some RAM buffer.
+ * Since a RAM buffer is not implemented tx interrupts are superfluous and unwanted
+ * because they block debug prints from within interrupt routines
+ */
+#ifdef RS232_CONF_TX_INTERRUPTS
+#define RS232_TX_INTERRUPTS RS232_CONF_TX_INTERRUPTS
+#else
+#define RS232_TX_INTERRUPTS 0
+#endif
+
+/* Insert a carriage return after a line feed. This is the default. */
+#ifndef ADD_CARRIAGE_RETURN_AFTER_NEWLINE
+#define ADD_CARRIAGE_RETURN_AFTER_NEWLINE 1
+#endif
+
+/* Reducing NUMPORTS from the default will harmlessly disable usage of those ports */
+/* Two ports take 400 bytes flash and 4 bytes RAM. */
+#ifdef RS232_CONF_NUMPORTS
+#define NUMPORTS RS232_CONF_NUMPORTS
+#endif
+
+#if defined (__AVR_ATmega128__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega128RFA1__)
+#ifndef NUMPORTS
+#define NUMPORTS 2
+#elif NUMPORTS > 2
+#error Only two serial ports are defined for this processor!
+#endif
+
+#if NUMPORTS > 0
+#define D_UDR0   UDR0
+#define D_UDRE0M (1 << UDRE0)
+#define D_UBRR0H UBRR0H
+#define D_UBRR0L UBRR0L
+#define D_UCSR0A UCSR0A
+#define D_UCSR0B UCSR0B
+#define D_UCSR0C UCSR0C
+#define D_USART0_RX_vect USART0_RX_vect
+#define D_USART0_TX_vect USART0_TX_vect
+
+#if NUMPORTS > 1
+#define D_UDR1   UDR1
+#define D_UDRE1M (1 << UDRE1)
+#define D_UBRR1H UBRR1H
+#define D_UBRR1L UBRR1L
+#define D_UCSR1A UCSR1A
+#define D_UCSR1B UCSR1B
+#define D_UCSR1C UCSR1C
+#define D_USART1_RX_vect USART1_RX_vect
+#define D_USART1_TX_vect USART1_TX_vect
+#endif
+
+#endif
+
+#elif defined (__AVR_AT90USB1287__)
+/* Has only UART1, map it to port 0 */
+#ifndef NUMPORTS
+#define NUMPORTS 1
+#elif NUMPORTS > 1
+#error Only one serial port is defined for this processor!
+#endif
+
+#if NUMPORTS > 0
+#define D_UDR0   UDR1
+#define D_UDRE0M (1 << UDRE1)
+#define D_UBRR0H UBRR1H
+#define D_UBRR0L UBRR1L
+#define D_UCSR0A UCSR1A
+#define D_UCSR0B UCSR1B
+#define D_UCSR0C UCSR1C
+#define D_USART0_RX_vect USART1_RX_vect
+#define D_USART0_TX_vect USART1_TX_vect
+#endif
+
+#elif defined (__AVR_ATmega8515__)
+#ifndef NUMPORTS
+#define NUMPORTS 1
+#elif NUMPORTS > 1
+#error Only one serial port is defined for this processor!
+#endif
+
+#if NUMPORTS > 0
+#define D_UDR0   UDR
+#define D_UDRE0M (1 << UDRE)
+#define D_UBRR0H UBRRH
+#define D_UBRR0L UBRRL
+#define D_UCSR0A UCSRA
+#define D_UCSR0B UCSRB
+#define D_UCSR0C UCSRC
+#define D_USART0_RX_vect USART_RX_vect
+#define D_USART0_TX_vect USART_TX_vect
+#endif
+
+#elif defined (__AVR_ATmega328P__)
+#ifndef NUMPORTS
+#define NUMPORTS 1
+#elif NUMPORTS > 1
+#error Only one serial port is defined for this processor!
+#endif
+
+#if NUMPORTS > 0
+#define D_UDR0   UDR0
+#define D_UDRE0M (1 << UDRE0)
+#define D_UBRR0H UBRR0H
+#define D_UBRR0L UBRR0L
+#define D_UCSR0A UCSR0A
+#define D_UCSR0B UCSR0B
+#define D_UCSR0C UCSR0C
+#define D_USART0_RX_vect USART_RX_vect
+#define D_USART0_TX_vect USART_TX_vect
+#endif
+
+#elif defined (__AVR_ATmega8__) || defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
+#ifndef NUMPORTS
+#define NUMPORTS 1
+#elif NUMPORTS > 1
+#error Only one serial port is defined for this processor!
+#endif
+
+#if NUMPORTS > 0
+#define D_UDR0   UDR
+#define D_UDRE0M (1 << UDRE)
+#define D_UBRR0H UBRRH
+#define D_UBRR0L UBRRL
+#define D_UCSR0A UCSRA
+#define D_UCSR0B UCSRB
+#define D_UCSR0C UCSRC
+#define D_USART0_RX_vect USART_RXC_vect
+#define D_USART0_TX_vect USART_TXC_vect
+#endif
+
+#elif defined (__AVR_ATmega644__)
+#ifndef NUMPORTS
+#define NUMPORTS 1
+#elif NUMPORTS > 1
+#error Only one serial port is defined for this processor!
+#endif
+
+#if NUMPORTS > 0
+#define D_UDR0   UDR0
+#define D_UDRE0M (1 << UDRE0)
+#define D_UBRR0H UBRR0H
+#define D_UBRR0L UBRR0L
+#define D_UCSR0A UCSR0A
+#define D_UCSR0B UCSR0B
+#define D_UCSR0C UCSR0C
+#define D_USART0_RX_vect USART0_RX_vect
+#define D_USART0_TX_vect USART0_TX_vect
+#endif
+
+#elif defined (__AVR_ATmega2560__)
+#ifndef NUMPORTS
+#define NUMPORTS 4
+#elif NUMPORTS > 4
+#error Only four serial ports are defined for this processor!
+#endif
+
+#if NUMPORTS > 0
+#define D_UDR0   UDR0
+#define D_UDRE0M (1 << UDRE0)
+#define D_UBRR0H UBRR0H
+#define D_UBRR0L UBRR0L
+#define D_UCSR0A UCSR0A
+#define D_UCSR0B UCSR0B
+#define D_UCSR0C UCSR0C
+#define D_USART0_RX_vect USART0_RX_vect
+#define D_USART0_TX_vect USART0_TX_vect
+
+#if NUMPORTS > 1
+#define D_UDR1   UDR1
+#define D_UDRE1M (1 << UDRE1)
+#define D_UBRR1H UBRR1H
+#define D_UBRR1L UBRR1L
+#define D_UCSR1A UCSR1A
+#define D_UCSR1B UCSR1B
+#define D_UCSR1C UCSR1C
+#define D_USART1_RX_vect USART1_RX_vect
+#define D_USART1_TX_vect USART1_TX_vect
+#endif
+
+#if NUMPORTS > 2
+#define D_UDR2   UDR2
+#define D_UDRE2M (1 << UDRE2)
+#define D_UBRR2H UBRR2H
+#define D_UBRR2L UBRR2L
+#define D_UCSR2A UCSR2A
+#define D_UCSR2B UCSR2B
+#define D_UCSR2C UCSR2C
+#define D_USART2_RX_vect USART2_RX_vect
+#define D_USART2_TX_vect USART2_TX_vect
+#endif
+
+#if NUMPORTS > 3
+#define D_UDR3   UDR3
+#define D_UDRE3M (3 << UDRE3)
+#define D_UBRR3H UBRR3H
+#define D_UBRR3L UBRR3L
+#define D_UCSR3A UCSR3A
+#define D_UCSR3B UCSR3B
+#define D_UCSR3C UCSR3C
+#define D_USART3_RX_vect USART3_RX_vect
+#define D_USART3_TX_vect USART3_TX_vect
+#endif
+#endif
+#else
+#error Please define the UART registers for your MCU!
+#endif
+
+#if NUMPORTS > 0
+int (* input_handler_0)(unsigned char);
+ISR(D_USART0_RX_vect)
+{
+  unsigned char c;
+  c = D_UDR0;
+  if (input_handler_0 != NULL) input_handler_0(c);
+}
+#if RS232_TX_INTERRUPTS
+volatile uint8_t txwait_0;
+ISR(D_USART0_TX_vect)
+{
+  txwait_0 = 0;
+}
+#endif
+
+#if NUMPORTS > 1
+int (* input_handler_1)(unsigned char);
+ISR(D_USART1_RX_vect)
+{
+  unsigned char c;
+  c = D_UDR1;
+  if (input_handler_1 != NULL) input_handler_1(c);
+}
+#if RS232_TX_INTERRUPTS
+volatile uint8_t txwait_1;
+ISR(USART1_TX_vect)
+{
+  txwait_1 = 0;
+}
+#endif
+
+#if NUMPORTS > 2
+int (* input_handler_2)(unsigned char);
+ISR(D_USART2_RX_vect)
+{
+  unsigned char c;
+  c = D_UDR2;
+  if (input_handler_2 != NULL) input_handler_2(c);
+}
+#if RS232_TX_INTERRUPTS
+volatile uint8_t txwait_2;
+ISR(USART2_TX_vect)
+{
+  txwait_2= 0;
+}
+#endif
+#endif
+
+#endif
+#endif
+/*---------------------------------------------------------------------------*/
+void
+rs232_init (uint8_t port, uint8_t bd, uint8_t ffmt)
+{
+#if NUMPORTS > 0
+ if (port == 0) {
+   D_UBRR0H = (uint8_t)(bd>>8);
+   D_UBRR0L = (uint8_t)bd;
+#if RS232_TX_INTERRUPTS
+   txwait_0 = 0;
+   D_UCSR0B =  USART_INTERRUPT_RX_COMPLETE | USART_INTERRUPT_TX_COMPLETE | \
+               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
+#else
+   D_UCSR0B =  USART_INTERRUPT_RX_COMPLETE | \
+               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
+#endif
+   D_UCSR0C = USART_UCSRC_SEL | ffmt;
+   input_handler_0 = NULL;
+
+#if NUMPORTS > 1
+ } else if (port == 1) {
+   D_UBRR1H = (uint8_t)(bd>>8);
+   D_UBRR1L = (uint8_t)bd;
+#if RS232_TX_INTERRUPTS
+   txwait_1 = 0;
+   D_UCSR1B =  USART_INTERRUPT_RX_COMPLETE | USART_INTERRUPT_TX_COMPLETE | \
+               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
+#else
+   D_UCSR1B =  USART_INTERRUPT_RX_COMPLETE | \
+               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
+#endif
+   D_UCSR1C = USART_UCSRC_SEL | ffmt;
+   input_handler_1 = NULL;
+
+#if NUMPORTS > 2
+ } else if (port == 2) {
+   D_UBRR2H = (uint8_t)(bd>>8);
+   D_UBRR2L = (uint8_t)bd;
+#if RS232_TX_INTERRUPTS
+   txwait_2 = 0;
+   D_UCSR2B =  USART_INTERRUPT_RX_COMPLETE | USART_INTERRUPT_TX_COMPLETE | \
+               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
+#else
+   D_UCSR2B =  USART_INTERRUPT_RX_COMPLETE | \
+               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
+#endif
+   D_UCSR2C = USART_UCSRC_SEL | ffmt;
+   input_handler_2 = NULL;
+#endif
+#endif
+ }
+#endif /* NUMPORTS > 0 */
+}
+
+/*---------------------------------------------------------------------------*/
+void 
+rs232_send(uint8_t port, unsigned char c)
+{
+#if RS232_TX_INTERRUPTS
+  /* Output character and block until it is transmitted */
+#if NUMPORTS > 0
+  if (port == 0 ) {
+    txwait_0 = 1;
+    D_UDR0 = c;
+    while (txwait_0);
+#if NUMPORTS > 1
+  } else if (port == 1) {
+    txwait_1 = 1;
+    D_UDR1 = c;
+    while (txwait_1);
+#if NUMPORTS > 2
+  } else if (port == 2) {
+    txwait_2 = 1;
+    D_UDR2 = c;
+    while (txwait_2);
+#endif
+#endif
+  }
+#endif
+#else /* RS232_TX_INTERRUPTS */
+  /* Block until tx ready and output character */
+#if NUMPORTS > 0
+  if (port == 0 ) {
+    while (!(D_UCSR0A & D_UDRE0M));
+    D_UDR0 = c;
+#if NUMPORTS > 1
+  } else if (port == 1) {
+    while (!(D_UCSR1A & D_UDRE1M));
+    D_UDR1 = c;
+#if NUMPORTS > 2
+  } else if (port == 2) {
+    while (!(D_UCSR2A & D_UDRE2M));
+    D_UDR2 = c;
+#endif
+#endif
+  }
+#endif
+#endif /* RS232_TX_INTERRUPTS */
+}
+/*---------------------------------------------------------------------------*/
+void
+rs232_set_input(uint8_t port, int (*f)(unsigned char))
+{
+#if NUMPORTS > 0
+  if (port == 0) {
+    input_handler_0 = f;
+#if NUMPORTS > 1
+  } else if (port == 1) {
+    input_handler_1 = f;
+#if NUMPORTS > 2
+  } else if (port == 2) {
+    input_handler_2 = f;
+#endif
+#endif
+  }
+#endif
+}
+
+/*---------------------------------------------------------------------------*/
+void
+rs232_print(uint8_t port, char *buf)
+{
+  while(*buf) {
+#if ADD_CARRIAGE_RETURN_AFTER_NEWLINE
+    if(*buf=='\n') rs232_send(port, '\r');
+	if(*buf=='\r') buf++; else rs232_send(port, *buf++);
+#else
+    rs232_send(port, *buf++);
+#endif
+  }
+}
+
+#if RS232_PRINTF_BUFFER_LENGTH
+/*---------------------------------------------------------------------------*/
+void
+rs232_printf(uint8_t port, const char *fmt, ...)
+{
+  va_list ap;
+  static char buf[RS232_PRINTF_BUFFER_LENGTH];
+
+  va_start (ap, fmt);
+  vsnprintf (buf, RS232_PRINTF_BUFFER_LENGTH, fmt, ap);
+  va_end(ap);
+
+  rs232_print (port, buf);
+}
+#endif
+/*---------------------------------------------------------------------------*/
+/*void
+slip_arch_writeb(unsigned char c)
+{
+  rs232_send(SLIP_PORT, c);
+}*/
+/*---------------------------------------------------------------------------*/
+int rs232_stdout_putchar(char c, FILE *stream);
+static uint8_t stdout_rs232_port=RS232_PORT_0;
+static FILE rs232_stdout = FDEV_SETUP_STREAM(rs232_stdout_putchar,
+					     NULL,
+					     _FDEV_SETUP_WRITE);
+
+int rs232_stdout_putchar(char c, FILE *stream)
+{
+#if ADD_CARRIAGE_RETURN_AFTER_NEWLINE
+  if(c=='\n') rs232_send(stdout_rs232_port, '\r');
+  if(c!='\r') rs232_send (stdout_rs232_port, c);
+#else
+  rs232_send (stdout_rs232_port, c);
+#endif
+  return 0;
+}
+/*---------------------------------------------------------------------------*/
+void rs232_redirect_stdout (uint8_t port) {
+  stdout_rs232_port = port;
+  stdout = &rs232_stdout;
+}
diff -ru deps/rs232/rs232.h deps_old/rs232/rs232.h
--- deps/rs232/rs232.h	2019-01-17 17:09:16.690057562 +0000
+++ deps_old/rs232/rs232.h	2019-01-17 17:14:17.740432406 +0000
@@ -0,0 +1,188 @@
+/*
+ * Copyright (c) 2005, Swedish Institute of Computer Science
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the Contiki operating system.
+ *
+ * Author:   Adam Dunkels <adam@sics.se>
+ *           Simon Barner <barner@in.tum.de>
+ *
+ */
+
+#ifndef __RS232_H__
+#define __RS232_H__
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+#include <avr/pgmspace.h>
+
+#if defined (__AVR_ATmega128__)
+//#include "dev/rs232_atmega128.h"
+#elif defined (__AVR_ATmega1281__)
+//#include "dev/rs232_atmega1281.h"
+#elif defined (__AVR_ATmega1284P__)
+//#include "dev/rs232_atmega1284.h"
+#elif defined (__AVR_AT90USB1287__)
+//#include "dev/rs232_at90usb1287.h"
+#elif defined (__AVR_ATmega128RFA1__)
+//#include "dev/rs232_atmega128rfa1.h"
+#elif defined (__AVR_ATmega644__) || defined (__AVR_ATmega328P__)
+//#include "dev/rs232_atmega644.h"
+#elif defined (__AVR_ATmega8__) || defined (__AVR_ATmega8515__) \
+   || defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
+//#include "dev/rs232_atmega32.h"
+#elif defined (__AVR_ATmega2560__)
+#include "rs232_atmega2560.h"
+#else
+#error "Please implement a rs232 header for your MCU (or set the MCU type \
+in contiki-conf.h)."
+#endif
+
+#ifndef MCU_MHZ
+ #define MCU_MHZ 16
+ #warning "Setting default MCU_MHZ value (@16MHz)"
+#endif
+
+/******************************************************************************/
+/***   Baud rates                                                             */
+/******************************************************************************/
+#define BAUD_RATE(x) (F_CPU/16/x-1)
+
+/* USART port configuration for serial I/O */
+#ifndef USART_PORT
+ #ifndef RS232_PORT_0
+	#error  "RS232 header was not included ?"
+ #else
+  #define USART_PORT (RS232_PORT_0)
+  #warning "Setting default RS232 I/O port (#0)"
+ #endif
+#endif
+
+#ifndef USART_BAUD
+ #ifndef USART_BAUD_115200 
+	#error  "RS232 header was not included ?"
+ #else
+  #define USART_BAUD (USART_BAUD_115200)
+  #warning "Setting default RS232 I/O baud rate (@9600)"
+ #endif
+#endif
+
+
+/**
+ * \brief      Initialize the RS232 module
+ *             This function is called from the boot up code to
+ *             initalize the RS232 module.
+ * \param port The RS232 port to be used.
+ * \param bd   The baud rate of the connection.
+ * \param ffmt The frame format of the connection, i.e. parity mode,
+ *             number of stop and data bits, ...
+ */
+void
+rs232_init (uint8_t port, uint8_t bd, uint8_t ffmt);
+
+/**
+ * \brief      Set an input handler for incoming RS232 data
+ * \param port The RS232 port to be used.
+ * \param f    A pointer to a byte input handler
+ *
+ *             This function sets the input handler for incoming RS232
+ *             data. The input handler function is called for every
+ *             incoming data byte. The function is called from the
+ *             RS232 interrupt handler, so care must be taken when
+ *             implementing the input handler to avoid race
+ *             conditions.
+ *
+ *             The return value of the input handler affects the sleep
+ *             mode of the CPU: if the input handler returns non-zero
+ *             (true), the CPU is awakened to let other processing
+ *             take place. If the input handler returns zero, the CPU
+ *             is kept sleeping.
+ */
+void
+rs232_set_input(uint8_t port, int (* f)(unsigned char));
+
+
+/**
+ * \brief      Print a text string from program memory on RS232
+ * \param port The RS232 port to be used.
+ * \param buf  A pointer to the string that is to be printed
+ *
+ *             This function prints a string from program memory to
+ *             RS232. The string must be terminated by a null
+ *             byte. The RS232 module must be correctly initalized and
+ *             configured for this function to work.
+ */
+void
+rs232_print(uint8_t port, char *buf);
+
+/**
+ * \brief      Print a formated string on RS232
+ * \param port The RS232 port to be used.
+ * \param fmt  The format string that is used to construct the string
+ *             from a variable number of arguments.
+ *
+ *             This function prints a formated string to RS232. Note
+ *             that this function used snprintf internally and thus cuts
+ *             the resulting string after RS232_PRINTF_BUFFER_LENGTH - 1
+ *             bytes. You can override this buffer lenght with the
+ *             RS232_CONF_PRINTF_BUFFER_LENGTH define. The RS232 module
+ *             must becorrectly initalized and configured for this
+ *             function to work.
+ */
+void
+rs232_printf(uint8_t port, const char *fmt, ...);
+
+/**
+ * \brief      Print a character on RS232
+ * \param port The RS232 port to be used.
+ * \param c    The character to be printed
+ *
+ *             This function prints a character to RS232. The RS232
+ *             module must be correctly initalized and configured for
+ *             this function to work.
+ */
+void
+rs232_send(uint8_t port, unsigned char c);
+
+/**
+ * \brief      Redirects stdout to a given RS232 port
+ * \param port The RS232 port to be used.
+ *
+ *             This function redirects the stdout channel to a given
+ *             RS232 port. Note that this modfies the global variable
+ *             stdout. If you want to restore the previous behaviour, it
+ *             is your responsibility to backup to old value. The RS232
+ *             module must be correctly initalized and configured for
+ *             the redirection to work.
+ */
+void
+rs232_redirect_stdout (uint8_t port);
+#ifdef __cplusplus
+}
+#endif
+#endif /* __RS232_H__ */
Only in deps_old/: socket
Only in deps_old/Time: build-mega2560
diff -ru deps/Time/Makefile deps_old/Time/Makefile
--- deps/Time/Makefile	2019-01-17 17:10:00.780102093 +0000
+++ deps_old/Time/Makefile	2019-01-17 17:14:17.720432366 +0000
@@ -0,0 +1,11 @@
+include ../../../setup.mk 
+
+ARDUINO_TIME_SRC  = $(wildcard $(PROJECT_DIR)/arduino-home/libraries/Time/*.cpp)
+
+LOCAL_CPP_SRCS += $(ARDUINO_TIME_SRC) 
+
+include $(ARDMK_DIR)/Arduino.mk 
+
+build-$(BOARD_TAG)/libarduino-time.a: $(LOCAL_OBJS)
+	$(AR) rcs $@ $(LOCAL_OBJS)
+	
Only in deps_old/wiz5500: build-mega2560
diff -ru deps/wiz5500/Makefile deps_old/wiz5500/Makefile
--- deps/wiz5500/Makefile	2019-01-17 17:10:50.320152233 +0000
+++ deps_old/wiz5500/Makefile	2019-01-17 17:14:17.700432325 +0000
@@ -0,0 +1,14 @@
+include ../../../setup.mk 
+
+SRC=$(wildcard ./*.cpp) 
+LOCAL_CPP_SRCS += $(SRC)
+
+CXXFLAGS +=-I../../adapter/include -I../../adapter/iotivity-constrained/port \
+          -I$(ARDUINO_DIR)/libraries/Ethernet2/src/utility
+
+include $(ARDMK_DIR)/Arduino.mk 
+
+build-$(BOARD_TAG)/libarduino-wiz5500.a: $(LOCAL_OBJS)
+	$(AR) rcs $@ $(LOCAL_OBJS)
+	
+
diff -ru deps/wiz5500/Wiz5500.cpp deps_old/wiz5500/Wiz5500.cpp
--- deps/wiz5500/Wiz5500.cpp	2019-01-17 17:11:00.580162631 +0000
+++ deps_old/wiz5500/Wiz5500.cpp	2019-01-17 17:14:17.700432325 +0000
@@ -0,0 +1,102 @@
+#include <Arduino.h>
+#include "Wiz5500.h"
+#include <w5500.h>
+#include "oc_log.h"
+
+struct wiz5500 {
+    void *w5500_ref;
+};
+// Use this pointer if u dont need the reimplemted methods
+wiz5500_t *wiznet5500 = NULL;
+
+wiz5500_t *wiz5500_create()
+{
+    wiz5500_t *wiznet_holder;
+    W5500Class *w5500_ref;
+		// allocate the wrapper memory
+    wiznet_holder  = (typeof(wiznet_holder))malloc(sizeof(*wiznet_holder));
+		if(wiznet_holder == NULL){
+			OC_ERR("Memory allocation failed for w5500");
+			return NULL;
+		}
+    #ifdef ETHERNET_DYNAMIC
+		w5500_ref    = w5500;
+		#else
+		w5500_ref    = &w5500;
+		#endif
+    wiznet_holder->w5500_ref = w5500_ref;
+    return wiznet_holder;
+}
+ 
+void wiz5500_destroy(wiz5500_t *wiznet_holder)
+{
+    if (wiznet_holder== NULL)
+        return;
+    // need to handle release of this resource
+    //delete static_cast<W5500Class *>(wiznet_holder->w5500_ref);
+    free(wiznet_holder);
+}
+void wiz5500_getIPAddress(wiz5500_t *wiznet_holder, uint8_t *addr){
+
+    W5500Class *w5500_ref;
+		
+    if (wiznet_holder == NULL) {
+			OC_ERR("w5500 allocated Memory unreachable!");
+		}
+    w5500_ref = static_cast<W5500Class *>(wiznet_holder->w5500_ref);
+    w5500_ref->getIPAddress(addr);
+}
+
+uint16_t wiz5500_getRXReceivedSize(wiz5500_t *wiznet_holder, uint8_t *socketID){
+
+    W5500Class *w5500_ref;
+    if (wiznet_holder == NULL) {
+			OC_ERR("w5500 allocated Memory unreachable!");
+			return 1;
+		}
+    w5500_ref = static_cast<W5500Class *>(wiznet_holder->w5500_ref);
+    return w5500_ref->getRXReceivedSize(*socketID);
+}
+
+uint8_t wiz5500_readSnSR(wiz5500_t *wiznet_holder, uint8_t *socketID){
+
+    W5500Class *w5500_ref;
+    if (wiznet_holder == NULL) {
+			OC_ERR("w5500 allocated Memory unreachable!");
+			return 1;
+		}
+    w5500_ref = static_cast<W5500Class *>(wiznet_holder->w5500_ref);
+    return w5500_ref->readSnSR(*socketID);
+}
+// return number of byte written to socket Sn DIPR register
+uint16_t wiz5500_writeSnDIPR(wiz5500_t *wiznet_holder, uint8_t *socketID, uint8_t *mcast_ipaddr){
+
+    W5500Class *w5500_ref;
+    if (wiznet_holder == NULL) {
+			OC_ERR("w5500 allocated Memory unreachable!");
+			return 1;
+		}
+    w5500_ref = static_cast<W5500Class *>(wiznet_holder->w5500_ref);
+    return w5500_ref->writeSnDIPR(*socketID,(uint8_t *)mcast_ipaddr);
+}
+
+// return number of byte written to socket Sn DIPR register
+uint16_t wiz5500_writeSnDHAR(wiz5500_t *wiznet_holder, uint8_t *socketID, uint8_t *mcast_mac_addr){
+    W5500Class *w5500_ref;
+    if (wiznet_holder == NULL) {
+			OC_ERR("w5500 allocated Memory unreachable!");
+			return 1;
+		}
+    w5500_ref = static_cast<W5500Class *>(wiznet_holder->w5500_ref);
+    return w5500_ref->writeSnDHAR(*socketID, mcast_mac_addr);
+}
+
+// return number of byte written to socket Sn DIPR register
+void wiz5500_writeSnDPORT(wiz5500_t *wiznet_holder, uint8_t *socketID, uint16_t *mcast_port){
+    W5500Class *w5500_ref;
+    if (wiznet_holder == NULL) {
+			OC_ERR("w5500 allocated Memory unreachable!");
+		}
+    w5500_ref = static_cast<W5500Class *>(wiznet_holder->w5500_ref);
+    w5500_ref->writeSnDPORT(*socketID, *mcast_port);
+}
\ No newline at end of file
diff -ru deps/wiz5500/Wiz5500.h deps_old/wiz5500/Wiz5500.h
--- deps/wiz5500/Wiz5500.h	2019-01-17 17:11:08.090170245 +0000
+++ deps_old/wiz5500/Wiz5500.h	2019-01-17 17:14:17.700432325 +0000
@@ -0,0 +1,65 @@
+#ifndef __WIZ5500_H__
+#define __WIZ5500_H__
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+// remove warning: ISO C++11 requires at least one argument for the "..." in a variadic macro
+//#pragma GCC system_header 
+#include <Arduino.h>
+
+#define SnMR_CLOSE  ((const uint8_t )0x00)
+#define SnMR_TCP    ((const uint8_t )0x01)
+#define SnMR_UDP    ((const uint8_t )0x02)
+#define SnMR_IPRAW  ((const uint8_t )0x03)
+#define SnMR_MACRAW ((const uint8_t )0x04)
+#define SnMR_PPPOE  ((const uint8_t )0x05)
+#define SnMR_ND     ((const uint8_t )0x20)
+#define SnMR_MULTI  ((const uint8_t )0x80)
+  
+#define SnSR_CLOSED      ((const uint8_t )0x00)
+#define SnSR_INIT        ((const uint8_t )0x13)
+#define SnSR_LISTEN      ((const uint8_t )0x14)
+#define SnSR_SYNSENT     ((const uint8_t )0x15)
+#define SnSR_SYNRECV     ((const uint8_t )0x16)
+#define SnSR_ESTABLISHED ((const uint8_t )0x17)
+#define SnSR_FIN_WAIT    ((const uint8_t )0x18)
+#define SnSR_CLOSING     ((const uint8_t )0x1A)
+#define SnSR_TIME_WAIT   ((const uint8_t )0x1B)
+#define SnSR_CLOSE_WAIT  ((const uint8_t )0x1C)
+#define SnSR_LAST_ACK    ((const uint8_t )0x1D)
+#define SnSR_UDP         ((const uint8_t )0x22)
+#define SnSR_IPRAW       ((const uint8_t )0x32)
+#define SnSR_MACRAW      ((const uint8_t )0x42)
+#define SnSR_PPPOE       ((const uint8_t )0x5F)
+
+
+
+
+struct wiz5500;
+typedef struct wiz5500 wiz5500_t;
+
+extern wiz5500_t *wiznet5500;// = NULL; 
+
+wiz5500_t *wiz5500_create();
+void wiz5500_destroy(wiz5500_t *wiznet_holder);
+
+// Maybe use a boolean to optimize RAM usage 
+void wiz5500_getIPAddress(wiz5500_t *wiznet_holder, uint8_t *addr);
+
+uint8_t wiz5500_readSnSR(wiz5500_t *wiznet_holder, uint8_t *socketID) ;
+
+uint16_t wiz5500_writeSnDIPR(wiz5500_t *wiznet_holder, uint8_t *socketID, uint8_t *_mcast_ipaddr);
+
+uint16_t wiz5500_writeSnDHAR(wiz5500_t *wiznet_holder, uint8_t *socketID, uint8_t *_buff);
+
+void wiz5500_writeSnDPORT(wiz5500_t *wiznet_holder, uint8_t *socketID, uint16_t *mport);
+
+uint16_t wiz5500_getRXReceivedSize(wiz5500_t *wiznet_holder, uint8_t *socketID);
+ 
+#ifdef __cplusplus
+}
+#endif
+ 
+#endif /* __WIZ5500_H__ */
